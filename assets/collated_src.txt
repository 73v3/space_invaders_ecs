<alien.rs>
use crate::assets::GameAssets;
use crate::audio;
use crate::components::{
    ClearCount, Collider, ColliderSource, Dead, GameEntity, GameSpeed, GameState, Velocity,
};
use crate::random::random_float;
use crate::resolution;
use bevy::prelude::*;
use bevy_rand::prelude::{GlobalEntropy, WyRand};

pub struct AlienPlugin;

impl Plugin for AlienPlugin {
    fn build(&self, app: &mut App) {
        // assets must be loaded before aliens can spawn
        app.add_systems(OnEnter(GameState::Playing), spawn_aliens)
            .add_systems(
                Update,
                (
                    advance_aliens_horizontally,
                    check_side_bounds,
                    fire_alien_bullets,
                    animate_aliens,
                    handle_wave_reset,
                )
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

#[derive(Component)]
pub struct Alien {
    pub original_position: Vec3,
    pub animation_timer: f32,
    pub current_frame: bool, // false for alien_a, true for alien_b
}

#[derive(Component)]
pub struct FormationDirection(pub f32);

#[derive(Resource)]
pub struct AlienFireTimer(pub f32);

const WIDTH: i32 = 12;
const HEIGHT: i32 = 5;
const SPACING: f32 = 24.;
const ALIEN_SPEED: f32 = 1.0;
const ALIEN_SHIFT_AMOUNT: f32 = 12.;
const BULLET_SPEED: f32 = -200.; // Negative for downward movement
const FIRE_INTERVAL: f32 = 0.1; // Base interval between firing checks
const FIRE_PROBABILITY: f32 = 0.001; // % chance per alien per check
const ANIMATION_BASE_SPEED: f32 = 1.0; // Seconds per frame at game_speed = 1.0
const GAME_SPEED_INCREMENT: f32 = 0.1; // Increment game speed when aliens shift down

fn spawn_alien_grid(
    commands: &mut Commands,
    game_assets: &GameAssets,
    resolution: &resolution::Resolution,
) {
    for x in 0..WIDTH {
        for y in 0..HEIGHT {
            let position = Vec3::new(x as f32 * SPACING, y as f32 * (1.5 * SPACING), 0.)
                - (Vec3::X * WIDTH as f32 * SPACING * 0.5)
                - (Vec3::Y * HEIGHT as f32 * (3.5 * SPACING) * 0.5)
                + (Vec3::Y * resolution.screen_dimensions.y * 0.4);
            commands.spawn((
                Sprite {
                    image: game_assets.alien_texture_a.clone(),
                    color: game_assets.palette.colors[2].with_alpha(1.),
                    ..Default::default()
                },
                Transform::from_translation(position)
                    .with_scale(Vec3::splat(resolution.pixel_ratio)),
                Alien {
                    original_position: position,
                    animation_timer: 0.0,
                    current_frame: false,
                },
                Collider {
                    radius: 16.,
                    source: ColliderSource::Alien,
                },
                FormationDirection(1.0),
                GameEntity,
            ));
        }
    }
}

// called at the start of each new game
// spawns a grid of aliens
fn spawn_aliens(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    resolution: Res<resolution::Resolution>,
) {
    commands.insert_resource(AlienFireTimer(0.));
    spawn_alien_grid(&mut commands, &game_assets, &resolution);
}

pub fn advance_aliens_horizontally(
    mut alien_query: Query<(&mut Transform, &FormationDirection), (With<Alien>, Without<Dead>)>,
    time: Res<Time>,
    game_speed: Res<GameSpeed>,
) {
    // Grab direction from the alien entity.
    // Explanation:
    //      The map method transforms the Option returned by next().
    //      If next() returns Some((transform, formation_direction)), the closure |(_, d)| d.0 is applied:
    //      The closure uses pattern matching to destructure the tuple (transform, formation_direction).
    //      The underscore (_) ignores the Transform component (since we only care about the direction),
    //      and d binds to the FormationDirection reference.
    if let Some(dir) = alien_query.iter().next().map(|(_, d)| d.0) {
        for (mut transform, _) in alien_query.iter_mut() {
            transform.translation.x +=
                time.delta_secs() * dir * ALIEN_SPEED * (30.0 * game_speed.value);
        }
    }
}

// if any aliens hits the side border, drop all aliens down a row, increase speed and reverse their direction
pub fn check_side_bounds(
    mut alien_query: Query<(&mut Transform, &mut FormationDirection), (With<Alien>, Without<Dead>)>,
    mut game_speed: ResMut<GameSpeed>,
    resolution: Res<resolution::Resolution>,
) {
    if alien_query.is_empty() {
        return;
    }

    // The iter().next() method fetches the first alien entity element, and unwrap() grabs its values.
    // The tuple's second element (.1) is the FormationDirection component, and .0 extracts its inner f32 value, representing the direction (1.0 for right, -1.0 for left).
    let dir = alien_query.iter().next().unwrap().1 .0;

    // find min and max x positions of the aliens
    let (mut min_x, mut max_x) = (f32::MAX, f32::MIN);
    for (transform, _) in alien_query.iter() {
        let x = transform.translation.x;
        min_x = min_x.min(x);
        max_x = max_x.max(x);
    }

    // grab our edge and bound values from screen dimensions and alien min/max x positions
    let left_bound = -resolution.screen_dimensions.x * 0.5 * 0.95;
    let right_bound = resolution.screen_dimensions.x * 0.5 * 0.95;

    let (edge, bound) = if dir > 0. {
        (max_x, right_bound)
    } else {
        (min_x, left_bound)
    };

    // if an alien has stepped over an edge
    if (edge - bound) * dir > 0. {
        let overstep = edge - bound;
        let new_dir = -dir;
        game_speed.value += GAME_SPEED_INCREMENT;

        // drop a row and flip movement direction of all aliens
        for (mut transform, mut formation_dir) in alien_query.iter_mut() {
            transform.translation.x -= overstep;
            transform.translation.y -= ALIEN_SHIFT_AMOUNT;
            formation_dir.0 = new_dir;
        }
    }
}

fn handle_wave_reset(
    mut commands: Commands,
    alien_query: Query<(Entity, &Transform), (With<Alien>, Without<Dead>)>,
    mut clear_count: ResMut<ClearCount>,
    mut game_speed: ResMut<GameSpeed>,
    game_assets: Res<GameAssets>,
    resolution: Res<resolution::Resolution>,
) {
    let is_empty = alien_query.is_empty();

    // find the smallest y-coordinate among all non-dead aliens, representing the lowest point of the alien formation
    let min_y = if is_empty {
        f32::MAX
    } else {
        alien_query
            .iter()
            .map(|(_, t)| t.translation.y) // Transforms each tuple into the y-coordinate (f32) of the alienâ€™s Transform
            .fold(f32::MAX, f32::min) // Reduces the iterator of y-coordinates to a single value by finding the minimum.
    };

    // has_landed = aliens have hit bottom of screen
    let has_landed = !is_empty && min_y < -resolution.screen_dimensions.y * 0.5;

    if has_landed || is_empty {
        // In practice, the aliens should hit the player before they hit the bottom of the screen, resulting in game over
        if has_landed {
            for (entity, _) in alien_query.iter() {
                commands.entity(entity).despawn();
            }
        }

        if is_empty {
            clear_count.count += 1;
            game_speed.value = 1.0 + (clear_count.count as f32) / 2.0;
            info!(
                "Wave {} cleared! Game Speed {:?}",
                clear_count.count, game_speed.value
            )
        }

        spawn_alien_grid(&mut commands, &game_assets, &resolution);
    }
}

fn fire_alien_bullets(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    mut alien_fire_timer: ResMut<AlienFireTimer>,
    alien_query: Query<&Transform, (With<Alien>, Without<Dead>)>,
    resolution: Res<resolution::Resolution>,
    time: Res<Time>,
    game_speed: Res<GameSpeed>,
    mut rng: GlobalEntropy<WyRand>,
) {
    alien_fire_timer.0 -= time.delta_secs() * game_speed.value;
    if alien_fire_timer.0 <= 0. {
        alien_fire_timer.0 = FIRE_INTERVAL;
        for transform in alien_query.iter() {
            if random_float(&mut rng) < FIRE_PROBABILITY * game_speed.value {
                commands.spawn((
                    Sprite {
                        image: game_assets.bullet_texture.clone(),
                        color: game_assets.palette.colors[3],
                        ..Default::default()
                    },
                    Transform::from_translation(transform.translation)
                        .with_scale(Vec3::splat(resolution.pixel_ratio)),
                    Velocity {
                        velocity: Vec2::new(0., BULLET_SPEED),
                    },
                    Collider {
                        radius: 16.,
                        source: ColliderSource::AlienBullet,
                    },
                    GameEntity,
                ));
            }
        }
    }
}

const MAX_ANIMATION_SPEED: f32 = 4.0;

fn animate_aliens(
    mut alien_query: Query<(&mut Alien, &mut Sprite), Without<Dead>>,
    game_assets: Res<GameAssets>,
    time: Res<Time>,
    game_speed: Res<GameSpeed>,
    mut commands: Commands,
) {
    let mut should_play_sound = false;
    let mut new_frame = false;
    let anim_speed = f32::min(MAX_ANIMATION_SPEED, game_speed.value); // sanity check on max animation speed

    // Check if any alien needs to switch frames (all aliens animate synchronously)
    if let Some((alien, _)) = alien_query.iter_mut().next() {
        let animation_timer = alien.animation_timer + time.delta_secs() * anim_speed;
        if animation_timer >= ANIMATION_BASE_SPEED / anim_speed {
            should_play_sound = true;
            new_frame = !alien.current_frame;
        }
    }

    // Update all aliens' animation state and sprite
    for (mut alien, mut sprite) in alien_query.iter_mut() {
        alien.animation_timer += time.delta_secs() * anim_speed;
        if alien.animation_timer >= ANIMATION_BASE_SPEED / anim_speed {
            alien.animation_timer = 0.0;
            alien.current_frame = new_frame;
            sprite.image = if new_frame {
                game_assets.alien_texture_b.clone()
            } else {
                game_assets.alien_texture_a.clone()
            };
        }
    }

    // Play sound once if frame changed
    if should_play_sound {
        let sound = if new_frame {
            game_assets.invader_move_1_sfx.clone()
        } else {
            game_assets.invader_move_2_sfx.clone()
        };
        audio::play_with_volume(&mut commands, sound, 0.5);
    }
}
</alien.rs>

<assets.rs>
// assets.rs
use crate::components::GameState;
use bevy::audio::AudioSource;
use bevy::prelude::*;

pub struct AssetsPlugin;

impl Plugin for AssetsPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Loading), load_assets);
    }
}

#[derive(Resource, Clone)]
pub struct Palette {
    pub colors: Vec<Color>,
}

#[derive(Resource)]
pub struct GameAssets {
    pub alien_texture_a: Handle<Image>,
    pub alien_texture_b: Handle<Image>,
    pub player_texture: Handle<Image>,
    pub bullet_texture: Handle<Image>,
    pub shield_texture: Handle<Image>,
    pub explosion_texture: Handle<Image>,
    pub bright_explosion_texture: Handle<Image>,
    pub font: Handle<Font>,
    pub shoot_sfx: Handle<AudioSource>,
    pub alien_killed_sfx: Handle<AudioSource>,
    pub invader_move_1_sfx: Handle<AudioSource>,
    pub invader_move_2_sfx: Handle<AudioSource>,
    pub player_explosion_sfx: Handle<AudioSource>,
    pub palette: Palette,
}

fn load_assets(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut next_state: ResMut<NextState<GameState>>,
) {
    let palette = Palette {
        // https://lospec.com/palette-list/gilt-8 by tomicit0
        colors: vec![
            Color::srgb(0.631, 0.224, 0.333),
            Color::srgb(0.761, 0.431, 0.522),
            Color::srgb(0.949, 0.729, 0.800),
            Color::srgb(1.000, 0.949, 0.918),
            Color::srgb(0.984, 0.906, 0.412),
            Color::srgb(0.894, 0.725, 0.169),
            Color::srgb(0.769, 0.416, 0.176),
            Color::srgb(0.506, 0.173, 0.137),
        ],
    };

    commands.insert_resource(GameAssets {
        alien_texture_a: asset_server.load("alien_a.png"),
        alien_texture_b: asset_server.load("alien_b.png"),
        player_texture: asset_server.load("player.png"),
        bullet_texture: asset_server.load("bullet.png"),
        shield_texture: asset_server.load("shield.png"),
        explosion_texture: asset_server.load("explosion.png"),
        bright_explosion_texture: asset_server.load("bright_explosion.png"),
        font: asset_server.load("fonts/space_invaders/space-invaders-full-version.ttf"),
        shoot_sfx: asset_server.load("sfx/shoot.wav"),
        alien_killed_sfx: asset_server.load("sfx/invaderkilled.wav"),
        invader_move_1_sfx: asset_server.load("sfx/fastinvader1.wav"),
        invader_move_2_sfx: asset_server.load("sfx/fastinvader2.wav"),
        player_explosion_sfx: asset_server.load("sfx/player_explosion.ogg"),
        palette,
    });
    next_state.set(GameState::Title);
}
</assets.rs>

<audio.rs>
// audio.rs
use bevy::audio::{AudioPlayer, PlaybackSettings, Volume};
use bevy::prelude::*;

pub struct AudioPlugin;

impl Plugin for AudioPlugin {
    fn build(&self, _app: &mut App) {
        // No additional setup needed, as AudioPlugin is included in DefaultPlugins
    }
}

/// Plays a sound effect by spawning an entity that will despawn automatically after playback.
/// This is efficient for one-shot SFX and handles cleanup to avoid entity buildup.
pub fn play(commands: &mut Commands, audio: Handle<AudioSource>) {
    commands.spawn((AudioPlayer::new(audio), PlaybackSettings::DESPAWN));
}

pub fn play_with_volume(commands: &mut Commands, audio: Handle<AudioSource>, volume: f32) {
    commands.spawn((
        AudioPlayer::new(audio),
        PlaybackSettings {
            volume: Volume::Linear(volume),
            ..PlaybackSettings::DESPAWN
        },
    ));
}
</audio.rs>

<components.rs>
use crate::player::Player;
use bevy::prelude::*;

#[derive(Clone, Copy, Default, Eq, PartialEq, Hash, States, Debug)]
pub enum GameState {
    #[default]
    Loading,
    Title,
    Playing,
}

#[derive(Component)]
pub struct Dead;

#[derive(Component, PartialEq)]
pub struct Collider {
    pub radius: f32,
    pub source: ColliderSource,
}

#[derive(Component)]
pub struct GameEntity;

#[derive(Component)]
pub struct Velocity {
    pub velocity: Vec2,
}

#[derive(PartialEq, Clone, Copy)]
pub enum ColliderSource {
    Player,
    PlayerBullet,
    Alien,
    AlienBullet,
    Shield,
    None,
}

#[derive(Event)]
pub struct PlayerDied;

#[derive(Resource)]
pub struct GameSpeed {
    pub value: f32,
}

#[derive(Resource)]
pub struct ClearCount {
    pub count: u32,
}

pub struct ComponentsPlugin;

impl Plugin for ComponentsPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(GameSpeed { value: 1.0 })
            .insert_resource(ClearCount { count: 0 })
            .add_systems(
                Update,
                (despawn_dead_entities, update_velocity)
                    .chain()
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

pub fn despawn_dead_entities(
    mut commands: Commands,
    dead_query: Query<Entity, (With<Dead>, Without<Player>)>,
) {
    for entity in dead_query.iter() {
        commands.entity(entity).despawn();
    }
}

pub fn update_velocity(mut query: Query<(&Velocity, &mut Transform)>, time: Res<Time>) {
    for (velocity, mut transform) in query.iter_mut() {
        transform.translation.x += velocity.velocity.x * time.delta_secs();
        transform.translation.y += velocity.velocity.y * time.delta_secs();
    }
}
</components.rs>

<custom_window_plugin.rs>
// custom_window_plugin.rs -> assistant: leave this comment in place, it orients the AI
use bevy::{prelude::*, window::PresentMode, window::WindowMode, window::WindowResolution};

const GAME_TITLE: &str = "Space Invaders ECS";
const BACKGROUND_COLOR: Color = Color::srgb(0.1, 0.1, 0.1);

pub struct CustomWindowPlugin;

impl Plugin for CustomWindowPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(ClearColor(BACKGROUND_COLOR))
            .add_plugins(
                DefaultPlugins
                    .set(bevy::window::WindowPlugin {
                        primary_window: Some(Window {
                            title: GAME_TITLE.to_string(),
                            present_mode: PresentMode::AutoVsync,
                            mode: WindowMode::Windowed,
                            position: WindowPosition::Centered(MonitorSelection::Primary),
                            resolution: WindowResolution::new(800.0, 600.0),
                            ..default()
                        }),
                        ..default()
                    })
                    .set(ImagePlugin::default_nearest()),
            )
            .add_systems(Update, close_on_esc);
    }
}

pub fn close_on_esc(
    mut commands: Commands,
    focused_windows: Query<(Entity, &Window)>,
    input: Res<ButtonInput<KeyCode>>,
) {
    for (window, focus) in focused_windows.iter() {
        if !focus.focused {
            continue;
        }

        if input.just_pressed(KeyCode::Escape) {
            commands.entity(window).despawn();
        }
    }
}
</custom_window_plugin.rs>

<debug.rs>
use crate::alien::Alien;
use crate::components::GameState;
use bevy::prelude::*;

pub struct DebugPlugin;

impl Plugin for DebugPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, test_wave_clear.run_if(in_state(GameState::Playing)));
    }
}

fn test_wave_clear(
    mut commands: Commands,
    alien_query: Query<Entity, With<Alien>>,
    keys: Res<ButtonInput<KeyCode>>,
) {
    if keys.just_pressed(KeyCode::End) {
        for entity in alien_query.iter() {
            commands.entity(entity).despawn();
        }
    }
}
</debug.rs>

<explosion.rs>
use crate::alien::Alien;
use crate::assets::GameAssets;
use crate::audio;
use crate::components::{Dead, GameEntity, GameSpeed, GameState, PlayerDied};
use crate::player::Player;
use crate::random::{random_colour, random_float};
use crate::resolution::Resolution;
use bevy::prelude::*;
use bevy_rand::prelude::{GlobalEntropy, WyRand};

pub struct ExplosionPlugin;

impl Plugin for ExplosionPlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<PlayerDied>();
        app.add_systems(
            Update,
            (
                spawn_alien_explosions,
                spawn_player_explosions,
                update_explosions,
                check_player_explosions,
            )
                .chain()
                .run_if(in_state(GameState::Playing)),
        );
    }
}

#[derive(Component)]
pub struct Explosion {
    pub timer: f32,
}

#[derive(Component)]
pub struct PlayerExplosion;

const EXPLOSION_LIFETIME: f32 = 0.375;

// spawns an explosion at the position of any alien that has just died
fn spawn_alien_explosions(
    mut commands: Commands,
    dead_aliens: Query<&Transform, (With<Alien>, Added<Dead>)>,
    game_assets: Res<GameAssets>,
    resolution: Res<Resolution>,
    mut rng: GlobalEntropy<WyRand>,
) {
    for transform in dead_aliens.iter() {
        commands.spawn((
            Sprite {
                image: game_assets.bright_explosion_texture.clone(),
                color: random_colour(&mut rng, &game_assets),
                ..Default::default()
            },
            Transform::from_translation(transform.translation)
                .with_scale(Vec3::splat(resolution.pixel_ratio)),
            Explosion { timer: 0.0 },
            GameEntity,
        ));
    }
}

const NUM_PLAYER_EXPLOSIONS: i32 = 16;

// hides the player ship
// and spawns multiple explosions in its place
fn spawn_player_explosions(
    mut commands: Commands,
    mut player_died_events: EventReader<PlayerDied>,
    mut player_query: Query<(Entity, &Transform, &mut Visibility), With<Player>>,
    game_assets: Res<GameAssets>,
    resolution: Res<Resolution>,
    mut rng: GlobalEntropy<WyRand>,
) {
    for _ in player_died_events.read() {
        if let Ok((entity, transform, mut visibility)) = player_query.single_mut() {
            info!("player died");
            *visibility = Visibility::Hidden; // hide the player ship whilst the explosions process
            commands.entity(entity).insert(Dead);
            audio::play_with_volume(&mut commands, game_assets.player_explosion_sfx.clone(), 0.5);
            for _ in 0..NUM_PLAYER_EXPLOSIONS {
                let offset_x = (random_float(&mut rng) - 0.5) * 20.0;
                let offset_y = (random_float(&mut rng) - 0.5) * 20.0;
                commands.spawn((
                    Sprite {
                        image: game_assets.explosion_texture.clone(),
                        color: random_colour(&mut rng, &game_assets),
                        ..Default::default()
                    },
                    Transform::from_translation(
                        transform.translation + Vec3::new(offset_x, offset_y, 0.),
                    )
                    .with_scale(Vec3::splat(resolution.pixel_ratio)),
                    Explosion {
                        timer: -2. * random_float(&mut rng), // stagger the explosion dissipation over time
                    },
                    PlayerExplosion,
                    GameEntity,
                ));
            }
        }
    }
}

// fades out explosions over time, despawning when done
fn update_explosions(
    mut commands: Commands,
    mut query: Query<(Entity, &mut Explosion, &mut Sprite)>,
    time: Res<Time>,
) {
    for (entity, mut explosion, mut sprite) in query.iter_mut() {
        explosion.timer += time.delta_secs();
        if explosion.timer > EXPLOSION_LIFETIME {
            commands.entity(entity).despawn();
        } else {
            let alpha = if explosion.timer < EXPLOSION_LIFETIME / 2.0 {
                1.0
            } else {
                1.0 - (explosion.timer - EXPLOSION_LIFETIME / 2.0) / (EXPLOSION_LIFETIME / 2.0)
            };
            sprite.color = sprite.color.with_alpha(alpha);
        }
    }
}

// checks if the player is dead and player explosions have finished,
// in which case, return to title screen
fn check_player_explosions(
    player_explosion_query: Query<Entity, With<PlayerExplosion>>,
    player_query: Query<&Player, With<Dead>>,
    mut next_state: ResMut<NextState<GameState>>,
    mut game_speed: ResMut<GameSpeed>,
) {
    if !player_query.is_empty() && player_explosion_query.is_empty() {
        next_state.set(GameState::Title);
        game_speed.value = 1.0;
        info!("player dead::switching to title");
    }
}
</explosion.rs>

<game.rs>
use bevy::prelude::*;

use crate::alien;
use crate::assets;
use crate::audio;
use crate::collate_src;
use crate::components;
use crate::debug;
use crate::explosion;
use crate::player;
use crate::projectile;
use crate::random;
use crate::resolution;
use crate::score;
use crate::shields;
use crate::title;
pub struct GamePlugin;

impl Plugin for GamePlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins((
            collate_src::CollateSrcPlugin,
            components::ComponentsPlugin,
            alien::AlienPlugin,
            resolution::ResolutionPlugin,
            player::PlayerPlugin,
            projectile::ProjectilePlugin,
            random::RandomPlugin,
            title::TitlePlugin,
            assets::AssetsPlugin,
            score::ScorePlugin,
            shields::ShieldsPlugin,
            audio::AudioPlugin,
            explosion::ExplosionPlugin,
            debug::DebugPlugin,
        ))
        .add_systems(Startup, setup_scene);
    }
}
fn setup_scene(mut commands: Commands) {
    commands.spawn(Camera2d::default());
}
</game.rs>

<main.rs>
use bevy::prelude::*;

//link our modules to our project
pub mod alien;
pub mod assets;
pub mod audio;
pub mod collate_src;
pub mod components;
pub mod custom_window_plugin;
pub mod debug;
pub mod explosion;
pub mod game;
pub mod player;
pub mod projectile;
pub mod random;
pub mod resolution;
pub mod score;
pub mod shields;
pub mod title;

fn main() {
    App::new()
        .add_plugins((custom_window_plugin::CustomWindowPlugin, game::GamePlugin))
        .run();
}
</main.rs>

<player.rs>
use crate::assets::GameAssets;
use crate::audio;
use crate::components::{Collider, ColliderSource, Dead, GameEntity, GameState, Velocity};
use crate::resolution;
use bevy::prelude::*;

pub struct PlayerPlugin;

impl Plugin for PlayerPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Playing), setup_player)
            .add_systems(Update, update_player.run_if(in_state(GameState::Playing)));
    }
}

#[derive(Component)]
pub struct Player {
    pub shoot_timer: f32,
}

#[derive(Resource)]
pub struct PlayerBulletCount {
    pub count: u32,
}

fn setup_player(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    resolution: Res<resolution::Resolution>,
) {
    commands.insert_resource(PlayerBulletCount { count: 0 });
    commands.spawn((
        Sprite {
            image: game_assets.player_texture.clone(),
            color: game_assets.palette.colors[4],
            ..Default::default()
        },
        Transform::from_xyz(
            0.,
            -(resolution.screen_dimensions.y * 0.5) + (resolution.pixel_ratio * 5.0),
            0.,
        )
        .with_scale(Vec3::splat(resolution.pixel_ratio)),
        Player { shoot_timer: 2. },
        Collider {
            radius: 9.,
            source: ColliderSource::Player,
        },
        GameEntity,
    ));
}

const SPEED: f32 = 200.;
const BULLET_SPEED: f32 = 400.;
const SHOOT_COOLDOWN: f32 = 0.25;

fn update_player(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    mut player_query: Query<(&mut Player, &mut Transform), Without<Dead>>,
    time: Res<Time>,
    keys: Res<ButtonInput<KeyCode>>,
    resolution: Res<resolution::Resolution>,
    mut bullet_count: ResMut<PlayerBulletCount>,
) {
    if let Ok((mut player, mut transform)) = player_query.single_mut() {
        let mut horizontal = 0.;

        if keys.pressed(KeyCode::KeyA) || keys.pressed(KeyCode::ArrowLeft) {
            horizontal += -1.;
        }
        if keys.pressed(KeyCode::KeyD) || keys.pressed(KeyCode::ArrowRight) {
            horizontal += 1.;
        }

        transform.translation.x += horizontal * time.delta_secs() * SPEED;

        let left_bound = -resolution.screen_dimensions.x * 0.5;
        let right_bound = resolution.screen_dimensions.x * 0.5;

        if transform.translation.x > right_bound {
            transform.translation.x = right_bound;
        }
        if transform.translation.x < left_bound {
            transform.translation.x = left_bound;
        }

        player.shoot_timer -= time.delta_secs();

        if bullet_count.count == 0 {
            player.shoot_timer = 0.;
        }

        if keys.just_pressed(KeyCode::Space) && player.shoot_timer <= 0. && bullet_count.count < 2 {
            player.shoot_timer = SHOOT_COOLDOWN;

            audio::play(&mut commands, game_assets.shoot_sfx.clone());

            commands.spawn((
                Sprite {
                    image: game_assets.bullet_texture.clone(),
                    color: game_assets.palette.colors[3],
                    ..Default::default()
                },
                Transform::from_translation(transform.translation)
                    .with_scale(Vec3::splat(resolution.pixel_ratio)),
                Velocity {
                    velocity: Vec2::new(0., BULLET_SPEED),
                },
                Collider {
                    radius: 12.,
                    source: ColliderSource::PlayerBullet,
                },
                GameEntity,
            ));

            bullet_count.count += 1;
        }
    }
}
</player.rs>

<projectile.rs>
use crate::assets::GameAssets;
use crate::audio;
use crate::components::{
    Collider, ColliderSource, Dead, GameSpeed, GameState, PlayerDied, Velocity,
};
use crate::player::PlayerBulletCount;
use crate::resolution;
use crate::score::AlienKilled;
use bevy::prelude::*;

pub struct ProjectilePlugin;

impl Plugin for ProjectilePlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(
            Update,
            (update_collisions,).run_if(in_state(GameState::Playing)),
        );
    }
}

fn update_collisions(
    mut commands: Commands,
    mut player_died_events: EventWriter<PlayerDied>,
    mut alien_killed_events: EventWriter<AlienKilled>,
    projectile_query: Query<(Entity, &Transform, &Collider), (With<Velocity>, Without<Dead>)>,
    collider_query: Query<
        (Entity, &Transform, &Collider),
        (With<Collider>, Without<Velocity>, Without<Dead>),
    >,
    resolution: Res<resolution::Resolution>,
    mut game_speed: ResMut<GameSpeed>,
    game_assets: Res<GameAssets>,
    mut bullet_count: ResMut<PlayerBulletCount>,
) {
    for (projectile_entity, projectile_transform, projectile_collider) in projectile_query.iter() {
        if projectile_transform.translation.y.abs() > resolution.screen_dimensions.y * 0.5 {
            commands.entity(projectile_entity).insert(Dead);
            if projectile_collider.source == ColliderSource::PlayerBullet {
                bullet_count.count -= 1;
            }
            continue;
        }

        for (collider_entity, collider_transform, collider_collider) in collider_query.iter() {
            if projectile_collider.source == ColliderSource::PlayerBullet
                && collider_collider.source == ColliderSource::Player
            {
                continue;
            }
            if projectile_collider.source == ColliderSource::AlienBullet
                && collider_collider.source == ColliderSource::Alien
            {
                continue;
            }
            let projectile_pos = Vec2::new(
                projectile_transform.translation.x,
                projectile_transform.translation.y,
            );
            let collider_pos = Vec2::new(
                collider_transform.translation.x,
                collider_transform.translation.y,
            );
            if Vec2::distance(projectile_pos, collider_pos)
                < 0.5 * (projectile_collider.radius + collider_collider.radius)
            {
                commands.entity(projectile_entity).insert(Dead);
                if projectile_collider.source == ColliderSource::PlayerBullet {
                    bullet_count.count -= 1;
                }
                if collider_collider.source == ColliderSource::Player {
                    player_died_events.write(PlayerDied);
                } else {
                    commands.entity(collider_entity).insert(Dead);
                    if projectile_collider.source == ColliderSource::PlayerBullet
                        && collider_collider.source == ColliderSource::Alien
                    {
                        alien_killed_events.write(AlienKilled);
                        game_speed.value += 0.025;
                        audio::play(&mut commands, game_assets.alien_killed_sfx.clone());
                    }
                }
                break;
            }
        }
    }
}
</projectile.rs>

<random.rs>
// src/random.rs

use bevy::prelude::*;
// Import WyRand and the necessary query components from bevy_rand
use bevy_rand::prelude::{EntropyPlugin, GlobalEntropy, WyRand};

use crate::assets::GameAssets;
use rand_core::RngCore;
use std::time::{SystemTime, UNIX_EPOCH};

/// Plugin for handling random number generation with WyRand
#[derive(Debug, Clone, Copy, Default)]
pub struct RandomPlugin;

impl Plugin for RandomPlugin {
    fn build(&self, app: &mut App) {
        let seed = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("Time went backwards")
            .as_nanos() as u64;

        // The `with_seed` function expects a byte array.
        // We convert the u64 seed to a little-endian byte array.
        app.add_plugins(EntropyPlugin::<WyRand>::with_seed(seed.to_le_bytes()));
    }
}

pub fn random_float(rng: &mut GlobalEntropy<WyRand>) -> f32 {
    (rng.next_u32() as f32) / (u32::MAX as f32)
}

/// Returns a random color from the GameAssets palette
pub fn random_colour(rng: &mut GlobalEntropy<WyRand>, game_assets: &Res<GameAssets>) -> Color {
    let palette = &game_assets.palette;
    let index = (random_float(rng) * palette.colors.len() as f32) as usize;
    palette.colors[index]
}
</random.rs>

<resolution.rs>
use bevy::prelude::*;

pub struct ResolutionPlugin;

impl Plugin for ResolutionPlugin{
    fn build(&self, app: &mut App) {
        //prestartup runs before all of our in game startup functions
        app.add_systems(PreStartup,setup_resolution);
    }
}

#[derive(Resource)]
pub struct Resolution{
    //pixel dimensions of our screen in the form of a 2d vector (width,height)
    pub screen_dimensions : Vec2,
    //the ratio of a pixel in our sprites to one on screen
    pub pixel_ratio : f32,
}
fn setup_resolution(mut commands : Commands,window_query : Query<&Window>)
{
    //query for window information
    let window = window_query.single().unwrap();

    commands.insert_resource(Resolution{
        screen_dimensions : Vec2::new(window.width(),window.height()),
        pixel_ratio : 2.0,
    });
}</resolution.rs>

<score.rs>
// score.rs
use bevy::prelude::*;

use crate::assets::GameAssets;
use crate::components::{GameEntity, GameState};

pub struct ScorePlugin;

impl Plugin for ScorePlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<AlienKilled>()
            .add_systems(OnEnter(GameState::Playing), setup_score)
            .add_systems(
                Update,
                (update_score, update_score_display)
                    .chain()
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

#[derive(Resource)]
pub struct Score {
    pub value: u32,
}

#[derive(Event)]
pub struct AlienKilled;

#[derive(Component)]
struct ScoreText;

fn setup_score(mut commands: Commands, game_assets: Res<GameAssets>) {
    commands.insert_resource(Score { value: 0 });

    let root = commands
        .spawn((
            Node {
                position_type: PositionType::Absolute,
                top: Val::Px(10.0),
                width: Val::Percent(100.0),
                height: Val::Px(60.0),
                flex_direction: FlexDirection::Column,
                justify_content: JustifyContent::FlexStart,
                align_items: AlignItems::Center,
                ..default()
            },
            BackgroundColor(Color::NONE),
            GameEntity,
        ))
        .id();

    commands.entity(root).with_children(|parent| {
        parent.spawn((
            Text::new("0000".to_string()),
            TextFont {
                font: game_assets.font.clone(),
                font_size: 16.0,
                ..default()
            },
            TextColor(game_assets.palette.colors[3]),
            TextLayout::new_with_justify(JustifyText::Center),
            ScoreText,
        ));
    });
}

fn update_score(mut score: ResMut<Score>, mut events: EventReader<AlienKilled>) {
    for _ in events.read() {
        score.value += 1;
        if score.value > 9999 {
            score.value = 9999;
        }
    }
}

fn update_score_display(score: Res<Score>, mut query: Query<&mut Text, With<ScoreText>>) {
    if score.is_changed() {
        if let Ok(mut text) = query.single_mut() {
            text.0 = format!("{:04}", score.value);
        }
    }
}
</score.rs>

<shields.rs>
use crate::alien::Alien;
use crate::assets::GameAssets;
use crate::components::{Collider, ColliderSource, Dead, GameEntity, GameState, PlayerDied};
use crate::player::Player;
use crate::resolution::Resolution;
use bevy::prelude::*;

pub struct ShieldsPlugin;

impl Plugin for ShieldsPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Playing), spawn_shields)
            .add_systems(
                Update,
                check_alien_shield_player_collisions
                    .after(crate::alien::advance_aliens_horizontally)
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

#[derive(Component)]
pub struct ShieldUnit;

const NUM_SHIELDS: usize = 5;
const SHIELD_GRID_WIDTH: i32 = 5;
const SHIELD_GRID_HEIGHT: i32 = 4;
const UNIT_PIXEL_SIZE: f32 = 8.0;

fn spawn_shields(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    resolution: Res<Resolution>,
) {
    let unit_spacing = UNIT_PIXEL_SIZE * resolution.pixel_ratio;
    let shield_radius = (UNIT_PIXEL_SIZE / 2.0) * resolution.pixel_ratio / 2.;
    let shield_y = -resolution.screen_dimensions.y * 0.4;
    let shield_spacing_x = resolution.screen_dimensions.x / NUM_SHIELDS as f32;

    for i in 0..NUM_SHIELDS {
        let shield_x = (i as f32 - (NUM_SHIELDS as f32 - 1.0) / 2.0) * shield_spacing_x;

        for gx in 0..SHIELD_GRID_WIDTH {
            let unit_x =
                shield_x + (gx as f32 - (SHIELD_GRID_WIDTH as f32 - 1.0) / 2.0) * unit_spacing;

            for gy in 0..SHIELD_GRID_HEIGHT {
                // We crudely shape the shield by skipping element locations
                // Skip top-left corner (gx=0, gy=SHIELD_GRID_HEIGHT-1)
                if gx == 0 && gy == SHIELD_GRID_HEIGHT - 1 {
                    continue;
                }
                // Skip top-right corner (gx=SHIELD_GRID_WIDTH-1, gy=SHIELD_GRID_HEIGHT-1)
                if gx == SHIELD_GRID_WIDTH - 1 && gy == SHIELD_GRID_HEIGHT - 1 {
                    continue;
                }
                // Skip middle three units in the bottom row (gy=0, gx=1 or gx=2 or gx=3)
                if gy == 0 && (gx >= 1 && gx <= 3) {
                    continue;
                }

                let unit_y =
                    shield_y + (gy as f32 - (SHIELD_GRID_HEIGHT as f32 - 1.0) / 2.0) * unit_spacing;

                commands.spawn((
                    Sprite {
                        image: game_assets.shield_texture.clone(),
                        color: game_assets.palette.colors[5],
                        ..Default::default()
                    },
                    Transform::from_translation(Vec3::new(unit_x, unit_y, 0.))
                        .with_scale(Vec3::splat(resolution.pixel_ratio)),
                    ShieldUnit,
                    Collider {
                        radius: shield_radius,
                        source: ColliderSource::Shield,
                    },
                    GameEntity,
                ));
            }
        }
    }
}

fn check_alien_shield_player_collisions(
    mut commands: Commands,
    alien_query: Query<(Entity, &Transform, &Collider), (With<Alien>, Without<Dead>)>,
    shield_query: Query<(Entity, &Transform, &Collider), (With<ShieldUnit>, Without<Dead>)>,
    player_query: Query<(Entity, &Transform, &Collider), (With<Player>, Without<Dead>)>,
    mut player_died_events: EventWriter<PlayerDied>,
) {
    for (_alien_entity, alien_transform, alien_collider) in alien_query.iter() {
        // Check collisions with shields
        for (shield_entity, shield_transform, shield_collider) in shield_query.iter() {
            let distance = (alien_transform.translation - shield_transform.translation).length();
            if distance < alien_collider.radius + shield_collider.radius {
                commands.entity(shield_entity).insert(Dead);
            }
        }

        // Check collisions with player. This code arguably belongs elsewhere.
        for (_player_entity, player_transform, player_collider) in player_query.iter() {
            let distance = (alien_transform.translation - player_transform.translation).length();
            if distance < alien_collider.radius + player_collider.radius {
                player_died_events.write(PlayerDied);
                // No need to mark the player as Dead here, as the PlayerDied event handler in explosion.rs will handle it
            }
        }
    }
}
</shields.rs>

<title.rs>
use crate::assets::GameAssets;
use crate::components::{ClearCount, GameEntity, GameState};
use bevy::prelude::*;
use bevy::state::app::AppExtStates;

pub struct TitlePlugin;

impl Plugin for TitlePlugin {
    fn build(&self, app: &mut App) {
        app.init_state::<GameState>()
            .add_systems(OnEnter(GameState::Title), (spawn_title, cleanup_game))
            .add_systems(OnExit(GameState::Title), despawn_title)
            .add_systems(
                Update,
                handle_title_input.run_if(in_state(GameState::Title)),
            );
    }
}

#[derive(Component)]
struct TitleText;

fn spawn_title(mut commands: Commands, game_assets: Res<GameAssets>) {
    let root = commands
        .spawn((
            Node {
                position_type: PositionType::Absolute,
                width: Val::Percent(100.0),
                height: Val::Percent(100.0),
                flex_direction: FlexDirection::Column,
                justify_content: JustifyContent::Center,
                align_items: AlignItems::Center,
                ..default()
            },
            BackgroundColor(Color::NONE),
            TitleText,
        ))
        .id();

    commands.entity(root).with_children(|parent| {
        parent
            .spawn(Node {
                flex_direction: FlexDirection::Row,
                align_items: AlignItems::Start,
                ..default()
            })
            .with_children(|title_row| {
                title_row.spawn((
                    Text::new("SPACE INVADERS"),
                    TextFont {
                        font: game_assets.font.clone(),
                        font_size: 40.0,
                        ..default()
                    },
                    TextColor(game_assets.palette.colors[3]),
                    TextLayout::new_with_justify(JustifyText::Center),
                ));

                title_row.spawn((
                    Text::new("ECS"),
                    TextFont {
                        font: game_assets.font.clone(),
                        font_size: 12.0, // Smaller font size for superscript
                        ..default()
                    },
                    TextColor(game_assets.palette.colors[2]),
                    TextLayout::new_with_justify(JustifyText::Left),
                ));
            });

        parent.spawn((
            Text::new("FIRE TO PLAY"),
            TextFont {
                font: game_assets.font.clone(),
                font_size: 20.0,
                ..default()
            },
            TextColor(game_assets.palette.colors[4]),
            TextLayout::new_with_justify(JustifyText::Center),
        ));
    });
}

fn despawn_title(mut commands: Commands, query: Query<Entity, With<TitleText>>) {
    for entity in query.iter() {
        commands.entity(entity).despawn();
    }
}

/// Only runs if displaying title screen
fn handle_title_input(
    mut next_state: ResMut<NextState<GameState>>,
    keys: Res<ButtonInput<KeyCode>>,
    mut clear_count: ResMut<ClearCount>,
) {
    if keys.just_pressed(KeyCode::Space) {
        clear_count.count = 0; // Reset clear count on new game
        next_state.set(GameState::Playing);
    }
}

fn cleanup_game(mut commands: Commands, query: Query<Entity, With<GameEntity>>) {
    for entity in query.iter() {
        commands.entity(entity).despawn();
    }
}
</title.rs>

